<!DOCTYPE HTML>
<!--
	Read Only by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
  <title>Bandpower of an EEG signal</title>
  <meta charset="utf-8" />
  <meta name="description" content="Raphael Vallat, PhD" />
  <meta name="author" content="Raphael Vallat, PhD" />
  <meta name="keywords" content="Raphael Vallat, raphaelvallat, Lyon Neuroscience Research Center, DYCOG, Lyon Neuroscience, Sleep research, Dream research" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
  <link rel="stylesheet" href="assets/css/main.css" />
  <link rel="stylesheet" href="assets/css/academicons.css" />
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
  <link rel="stylesheet" href="assets/css/sunburst.css">

  <!-- Add Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans|Noto+Serif|Roboto+Mono" rel="stylesheet">

  <script src="assets/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  <!--[if lte IE 8]><link rel="stylesheet" href="assets/css/ie8.css" /><![endif]-->
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118198513-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());
    gtag('config', 'UA-118198513-1');
  </script>

</head>

<body>

  <!-- Header -->
  <section id="header">
    <header>
      <!-- <span class="image avatar"><img src="images/avatar.jpg" alt="" /></span> -->
      <h1 id="logo"><a href="#">Raphael Vallat</a></h1>
      <p>Postdoctoral fellow<br>Walker Lab, U.C Berkeley</p>
    </header>
    <nav id="nav">
      <ul>
        <li><a href="index.html#one">About</a></li>
        <li><a href="index.html#two">News</a></li>
        <li><a href="index.html#three">Academics</a></li>
        <li><a href="index.html#four">Publications</a></li>
        <li><a href="index.html#five">Media</a></li>
        <li><a href="index.html#six">Softwares</a></li>
        <li><a href="index.html#seven" class="active">Guides</a></li>
      </ul>
    </nav>
    <footer>
      <ul class="icons">
        <li><a href="https://github.com/raphaelvallat" class="icon fa-github" target="_blank"><span class="label">Github</span></a></li>
        <li><a href="mailto:raphaelvallat9@gmail.com" class="icon fa-envelope"><span class="label">Email</span></a></li>
        <li><a href="https://scholar.google.fr/citations?user=XH8IG2UAAAAJ" style="border:none" class="ai ai-google-scholar ai-1x" target="_blank"></a></li>
        <li><a href="https://www.researchgate.net/profile/Raphael_Vallat2" style="border:none" class="ai ai-researchgate ai-1x" target="_blank"></a></li>
        <li><a href="https://twitter.com/RaphaelVallat" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
      </ul>
    </footer>
  </section>

  <!-- Wrapper -->
  <div id="wrapper">

    <!-- Main -->
    <div id="main">

      <div class="container">

        <header>
          <h3>Compute the average bandpower of an EEG signal</h3>
          <p>May 2018</p>
        </header>

        <p align="justify">Welcome to this first tutorial on EEG signal processing in Python!
          <br><br>We are going to see how to compute the <b>average power of a signal in a specific frequency range</b>, using both <b>Welch and the multitaper spectral estimation methods</b>. This tutorial is mainly geared for neuroscientists / sleep
          researchers with some basic knowledge of EEG signal processing.</p>

        <hr />

        <h4>Foreword</h4>

        <p align="justify">One of the most widely used method to analyze EEG data is to decompose the signal into functionally distinct frequency bands, such as <a href="https://en.wikipedia.org/wiki/Delta_wave" target="_blank">delta</a> (0.5–4 Hz), <a href="https://en.wikipedia.org/wiki/Theta_wave"
            target="_blank">theta</a> (4–7 Hz), <a href="https://en.wikipedia.org/wiki/Alpha_wave" target="_blank">alpha</a> (8–12 Hz), <a href="https://en.wikipedia.org/wiki/Beta_wave" target="_blank">beta</a> (12–30 Hz), and <a href="https://en.wikipedia.org/wiki/Gamma_wave"
            target="_blank">gamma</a> (30–100 Hz).
          <p>

            <span class="image fit"><img src="images/tutorials/bandpower/brain_waves.png" alt="Brain waves"/></span>

            <p align="justify">This implies the decomposition of the EEG signal into frequency components, which is commonly achieved through <a href="https://en.wikipedia.org/wiki/Fourier_transform" target="_blank">Fourier transforms</a>. The almost invariably used algorithm
              to compute the Fourier transform (and probably the most important signal processing algorithm) is the <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform" target="_blank">Fast Fourier Transform (FFT)</a>, which returns, for each frequency bin, a complex number containing the amplitude
              and the phase. In spectral analysis, it is then common to take the squared absolute magnitudes of the FFT to obtain an estimate of the <a href="https://en.wikipedia.org/wiki/Spectral_density" target="_blank">power spectral density</a> (or power spectrum, or <b>periodogram</b>), typically expressed in (micro)-Volts<sup>2</sup> per Hertz.</p>

              <ul class="feature-icons">
                <li class="fa-book">If the previous paragraph is completely obscure for you, I recommand checking out this <a href="https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/" target="_blank">blog post</a> or this <a href="https://www.youtube.com/watch?v=spUNpyF58BY" target="_blank">video</a> on the Fourier Transform before going further!</li>
              </ul>

              <p align="justify">While several type of analyses can be performed with power spectral density, I am going to focus here on a very simple one: the <b>average band power</b>. For instance, if you are looking at EEG sleep data and are interested in slow-wave
                sleep (N3 sleep), which are characterized by high delta activity, you might want to know <i>"what is the average spectral power of the delta frequency band during slow-wave sleep?"</i>.
                <br><br>Typically, higher delta values indicate a higher amount of slow-waves and are associated with increased subjective sleep quality (sleep is perceived as more "refreshing"). Using that simple metric, it then becomes easy to compare
                objective sleep quality between groups (e.g. insomniacs versus control, old vs young...) or within individuals.</p>

              <hr />

              <h4>Data loading</h4>

              <p align="justify">For the sake of this tutorial, please find below a 30-seconds extract of real slow-wave sleep from one young individual. The sampling frequency is 100 Hz and the channel is F3.</p>

              <ul class="actions" align="center">
                <li><a href="images/tutorials/bandpower/data.txt" class="button special icon fa-download" download>Download the raw EEG data (.txt, ~200 Ko)</a></li>
              </ul>

              <p align="justify">Time to open your favorite Python editor! Loading the data is fairly easy:</p>

              <pre><code class="python">import numpy as np
data = np.loadtxt('data.txt')</code></pre>

              <p align="justify">Let's take a look at the data:</p>

              <pre><code class="python">import matplotlib.pyplot as plt
import seaborn as sns
sns.set(font_scale=1.2)

# Define sampling frequency and time vector
sf = 100.
time = np.arange(data.size) / sf

# Plot the signal
fig, ax = plt.subplots(1, 1, figsize=(12, 4))
plt.plot(time, data, lw=1.5, color='k')
plt.xlabel('Time (seconds)')
plt.ylabel('Voltage')
plt.xlim([time.min(), time.max()])
plt.title('N3 sleep EEG data (F3)')
sns.despine()
</code></pre>

              <span class="image fit"><img src="images/tutorials/bandpower/signal.png" alt="" /></span>

              <hr />

              <h4>Computing the power spectral density</h4>

              <p align="justify">Now let's say that you want to compute the average power of the Delta frequency band (0.5 - 4.5 Hz). To do that, we first need to compute an estimate of the power spectral density. The most widely-used method to do that is the <a href="https://en.wikipedia.org/wiki/Welch%27s_method"
                  target="_blank">Welch's periodogram</a>, which consists in averaging consecutive Fourier transform of small windows of the signal, with or without overlapping. The Welch's method improves the accuracy of the classic periodogram (i.e. just
                squaring the absolute magnitudes of the FFT obtained on the whole signal). <br><br>The reason is simple: EEG data are always time-varying, meaning that if you look at a 30 seconds of EEG data, it is very (very) unlikely that the signal will looks like a perfct sum
                of pure sines. Rather, the spectral content of the EEG changes over time, constantly modified by the neuronal activity at play under the scalp. Problem is, to return a true spectral estimate, a classic periodogram requires
                the spectral content of the signal to be stationnary (i.e. time-unvarying) over the time period considered. Because it is never the case, the periodogram is generally biased and contains way too much variance (see the end of this tutorial).
                By averaging the periodograms obtained over short segments of the windows, the Welch's method allows to drastically reduce this variance, at the cost of a loss in the frequency resolution. Indeed, the longer the signal is, the higher the
                frequency resolution of the FFT is.
                <br><br>In the example below, we are going to compute and plot a Welch's periodogram of our 30-seconds signal, by averaging over 4-seconds windows. We choose this 4 seconds limits to get at least two full cycles of the lowest frequency
                of the delta band ((1 / 0.5 Hz) * 2 = 4 seconds).</p>

              <pre><code class="python">from scipy import signal

# Define window length (4 seconds)
win = 4 * sf
freqs, psd = signal.welch(data, sf, nperseg=win, scaling='density')

# Plot the power spectrum
sns.set(font_scale=1.2, style='white')
plt.figure(figsize=(8, 4))
plt.plot(freqs, psd, color='k', lw=2)
plt.xlabel('Frequency (Hz)')
plt.ylabel('Power spectral density (V^2 / Hz)')
plt.ylim([0, psd.max() * 1.1])
plt.title("Welch's periodogram")
plt.xlim([0, 20])
sns.despine()
</code></pre>

              <span class="image fit"><img src="images/tutorials/bandpower/psd.png" alt="" /></span>


              <p align="justify">The <code>freqs</code> vector contains the x-axis (frequency bins) and the <code>psd</code> vector contains the y-axis (power spectral density). The units of the power spectral density, when working with EEG data, is (micro)-Volts-squared per Hz
                (uV^2/Hz).</p>

              <ul class="feature-icons">
                <li class="fa-exclamation-triangle">Note that the maximum value of the x-axis is always half the sampling frequency, which corresponds to the <a href="https://en.wikipedia.org/wiki/Nyquist_frequency" target="_blank">Nyquist frequency</a>.</li>
              </ul>

              <hr />

              <h4>Defining the delta band</h4>

              <p align="justify">Now, before computing the average delta bandpower, we need to find the frequency bins that intersect our delta band (i.e. 0.5 <= freqs < 4).</p>

              <pre><code class="python"># Define delta lower and upper limits
low, high = 0.5, 4

# Find closest values in freqs vector
idx_delta = np.logical_and(freqs >= low, freqs < high)

# Plot the power spectral density and fill the area comprising the delta band
plt.figure(figsize=(7, 4))
plt.plot(freqs, psd, lw=2, color='k')
plt.fill_between(freqs, psd, where=idx_delta, color='skyblue',
                  linestyle=':', linewidth=1.5, edgecolor='grey')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Power spectral density (V^2 / Hz)')
plt.xlim([0, 10])
plt.ylim([0, psd.max() * 1.1])
plt.title("Welch's periodogram")
sns.despine()
</code></pre>

              <span class="image fit"><img src="images/tutorials/bandpower/psd_area.png" alt="" /></span>


              <hr />

              <h4>Average band power</h4>

              <p align="justify">The absolute delta power is equal to the blue area of the previous plot. As there is no closed-form formula to integrate this area, we need to approximate it. This is commonly achieved using the <a href="https://en.wikipedia.org/wiki/Simpson%27s_rule"
                  target="_blank">composite Simpson's rule</a>. The idea behind it is actually very simple: we decompose this area into several parabola and then sum the area of these parabola. Note that this could also be done using trapezoid (trapezoid
                rule) or rectangle (as in the Matlab <a href="https://www.mathworks.com/help/signal/ref/bandpower.html" target="_blank">bandpower</a> function), but parabola typically give <a href="https://stackoverflow.com/a/44915647/10581531" target="_blank">better estimates</a>.</p>

              <pre><code class="python"># Compute the absolute power by approximating the area under the curve
from scipy.integrate import simps
delta_power = simps(psd[idx_delta], freqs[idx_delta]) # Same as: (freqs[1] - freqs[0]) * simps(psd[idx_delta])
print('Absolute delta power: %.3f V^2' % delta_power)
</code></pre>

              <blockquote><b>Absolute &delta; power:</b> 315.253 volts-squared</blockquote>

              <h5>Relative power</h5>

              <p align="justify">In practice, rather than reporting the absolute band power, one may want to express the power in a frequency band as a percentage of the total power of the signal. This is called the relative band power. It can be calculated very easily
                from the above:
              </p>

              <pre><code class="python"># Relative delta power (expressed as a percentage of total power)
total_power = simps(psd, freqs)
delta_rel_power = delta_power / total_power
print('Relative delta power: %.3f' % delta_rel_power)
</code></pre>

              <blockquote><b>Relative &delta; power:</b> 0.774</blockquote>

              <p align="justify">In other words, 77.4% of the total power of the signal is contained in the delta frequency band.</p>

              <hr />

              <h4>Generalization</h4>

              <p align="justify">The function below is a generalization of the above which can be used to easily get the average absolute or relative power in a specific frequency band. It is very similar to the Matlab <a href="https://www.mathworks.com/help/signal/ref/bandpower.html"
                  target="_blank">bandpower</a> function, the two main differences being that it uses a Welch's periodogram instead of a classical periodogram, and parabola instead of rectangles to approximate the area.</p>

              <pre><code class="python">def bandpower(data, sf, band, window_sec=None, relative=False):
    """Compute the average power of the signal x in a specific frequency band.

    Parameters
    ----------
    data : 1d-array
        Input signal in the time-domain.
    sf : float
        Sampling frequency of the data.
    band : list
        Lower and upper frequencies of the band of interest.
    window_sec : float
        Length of each window in seconds.
        If None, window_sec = (1 / min(band)) * 2
    relative : boolean
        If True, return the relative power (= divided by the total power of the signal).
        If False (default), return the absolute power.

    Return
    ------
    bp : float
        Absolute or relative band power.

    Examples
    ------
    1. Absolute and relative power in the delta band
        >>> delta = bandpower(data, 100, [0.5, 4])
        >>> delta_relative = bandpower(data, 100, [0.5, 4], relative=True)

    2. Delta / beta ratio
        >>> window_sec = 4
        >>> delta = bandpower(data, 100, [0.5, 4], window_sec)
        >>> beta = bandpower(data, 100, [12, 30], window_sec)
        >>> db_ratio = delta / beta
    """
    from scipy.signal import welch
    from scipy.integrate import simps
    band = np.asarray(band)
    low, high = band

    # Compute the modified periodogram (Welch)
    if window_sec is not None:
        nperseg = window_sec * sf
    else:
        nperseg = (2 / low) * sf

    freqs, psd = welch(data, sf, nperseg=nperseg, scaling='density')

    # Find closest indices of band in frequency vector
    idx_band = np.logical_and(freqs >= low, freqs < high)

    # Integral approximation of the spectrum using Simpson's rule.
    bp = simps(psd[idx_band], freqs[idx_band])

    if relative:
        bp /= simps(psd, freqs)
    return bp
</code></pre>

              <hr />

              <h4>Ratio between two frequency bands</h4>

              <p align="justify">It is also very common to report the ratios between two frequency bands. For instance, the delta / beta ratio is a well-known index of slow-wave sleep quality. When computing ratios between two bands, it is important to control that the
                window length of the periodogram is the same for the two bands. Indeed, if you are using a different window length for the two bands, this will result in two different periodograms and the ratio will therefore be meaningless.</p>

              <pre><code class="python"># Define the duration of the window to be 4 seconds
win_sec = 4

# Delta/beta ratio based on the absolute power
db = bandpower(data, sf, [0.5, 4], win_sec) / bandpower(data, sf, [12, 30], win_sec)

# Delta/beta ratio based on the relative power
db_rel = bandpower(data, sf, [0.5, 4], win_sec, True) / bandpower(data, sf, [12, 30], win_sec, True)
</code></pre>

              <blockquote><b>&delta;/&beta; ratio (absolute)</b>: 41.501<br>
                <b>&delta;/&beta; ratio (relative)</b>: 41.501</blockquote>

              <hr />

              <h4>Using the multitaper method</h4>

              <p align="justify">Multitaper is a spectral analysis method first developed by David J. Thompson in 1982 in order to overcome some of the limitations of the classical spectral estimation techniques. It provides a more robust spectral estimation than the classical
                and Welch's periodograms, by combining the advantages of the two methods: high frequency resolution and low variance.
                <br><br>To understand how it works, I really encourage you to read <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5343535/">this paper by Prerau et al. (2017)</a> that explains very well what is multitaper and how sleep research
                and sleep medicine could benefit from it. Another source that was useful for me was the <a href="https://www.mathworks.com/examples/signal/mw/signal-ex41524780-multitaper-method" target="_blank">Matlab documentation on Multitaper spectral analyses</a>.
                <br><br>In a nutshell, the multitaper method starts by filtering the original signal with a set of optimal bandpass filter, called Slepian sequences (or DPSS). This filtering is done by convoluting the original signal with the Slepian sequences. Second, a classic
                periodogram is calculated for each of these new filtered (or "tapered") data and the final spectrum is then obtained by averaging over all the resulting
                periodogram. The real strength of the multitaper method comes from the fact that the Slepian sequences are orthogonal to all others and therefore the tapered signals provide statistically independent estimates of the underlying spectrum.
                In other words, each filtered signal will highlight one specific aspect of the spectral content of the signal.</p>


              <span class="image fit">
  <figure>
  <img src="images/tutorials/bandpower/prerau_article.jpg" alt="The Multitaper technique (Prerau et al. 2017)"/>
  <figcaption>Schematic of multitaper spectral estimation (from <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5343535/">Prerau et al. 2017</a>)</figcaption>
</figure>
</span>

              <h5>Average bandpower using Multitaper</h5>
              <p align="justify">The multitaper spectral estimation method is implemented in the <a href="https://www.martinos.org/mne/stable/index.html" target="_blank">MNE-Python package</a>. In the following example, I adapted the bandpower function that we have created
                previously to add the multitaper method.</p>

              <pre><code class="python">def bandpower(data, sf, band, method='welch', window_sec=None, relative=False):
  """Compute the average power of the signal x in a specific frequency band.

  Requires MNE-Python >= 0.14.

  Parameters
  ----------
  data : 1d-array
      Input signal in the time-domain.
  sf : float
      Sampling frequency of the data.
  band : list
      Lower and upper frequencies of the band of interest.
  method : string
      Periodogram method: 'welch' or 'multitaper'
  window_sec : float
      Length of each window in seconds. Useful only if method == 'welch'.
      If None, window_sec = (1 / min(band)) * 2.
  relative : boolean
      If True, return the relative power (= divided by the total power of the signal).
      If False (default), return the absolute power.

  Return
  ------
  bp : float
      Absolute or relative band power.
  """
  from scipy.signal import welch
  from scipy.integrate import simps
  from mne.time_frequency import psd_array_multitaper

  band = np.asarray(band)
  low, high = band

  if band.size != 2:
      raise ValueError("You must specify the lower and upper frequencies of the band.")

  # Compute the modified periodogram (Welch)
  if method == 'welch':
      if window_sec is not None:
          nperseg = window_sec * sf
      else:
          nperseg = (2 / low) * sf

      freqs, psd = welch(data, sf, nperseg=nperseg, scaling='density')

  elif method == 'multitaper':
      psd, freqs = psd_array_multitaper(data, sf, adaptive=True, normalization='full')

  # Find index of band in frequency vector
  idx_band = np.logical_and(freqs >= low, freqs < high)

  # Integral approximation of the spectrum using parabola (Simpson's rule)
  bp = simps(psd[idx_band], freqs[idx_band])

  if relative:
      bp /= simps(psd, freqs)
  return bp
</code></pre>

              <p align="justify">Let's try our new function with the code below. One advantage of the Multitaper method compared to the Welch's method is that we don't need to specify a window duration as it will basically compute the periodogram on the whole signal.</p>

            <pre><code class="python"># Multitaper delta power
bp = bandpower(data, sf, [0.5, 4], 'multitaper')
bp_rel = bandpower(data, sf, [0.5, 4], 'multitaper', relative=True)
print('Absolute delta power: %.3f' % bp)
print('Relative delta power: %.3f' % bp_rel)

# Delta-beta ratio
# One advantage of the multitaper is that we don't need to define a window length.
db = bandpower(data, sf, [0.5, 4], 'multitaper') / bandpower(data, sf, [12, 30], 'multitaper')
# Ratio based on the relative power
db_rel = bandpower(data, sf, [0.5, 4], 'multitaper', relative=True) / \
                    bandpower(data, sf, [12, 30], 'multitaper', relative=True)
print('Delta/beta ratio (absolute): %.3f' % db)
print('Delta/beta ratio (relative): %.3f' % db_rel)
</code></pre>

              <blockquote>
                <b>Absolute &delta; power</b>: 311.198<br>
                <b>Relative &delta; power</b>: 0.789<br>
                <b>&delta;/&beta; ratio (absolute)</b>: 41.020<br>
                <b>&delta;/&beta; ratio (relative)</b>: 41.020
              </blockquote>

              <p align="justify">The results are very close to the one obtained using Welch's method. This should remain true as long as your data are not too noisy. However, if you are working with noisy data, the multitaper method will always provide a much more
                robust spectral estimation than Welch's.
                <br><br>Just for fun, let's compare the power spectral density estimate obtained using a classic periodogram, a Welch's periodogram, and the multitaper method:</p>

              <pre><code class="python">def plot_spectrum_methods(data, sf, window_sec, band=None, dB=False):
    """Plot the periodogram, Welch's and multitaper PSD.

    Requires MNE-Python >= 0.14.

    Parameters
    ----------
    data : 1d-array
        Input signal in the time-domain.
    sf : float
        Sampling frequency of the data.
    band : list
        Lower and upper frequencies of the band of interest.
    window_sec : float
        Length of each window in seconds for Welch's PSD
    dB : boolean
        If True, convert the power to dB.
    """
    from mne.time_frequency import psd_array_multitaper
    from scipy.signal import welch, periodogram
    sns.set(style="white", font_scale=1.2)
    # Compute the PSD
    freqs, psd = periodogram(data, sf)
    freqs_welch, psd_welch = welch(data, sf, nperseg=window_sec*sf)
    psd_mt, freqs_mt = psd_array_multitaper(data, sf, adaptive=True, normalization='full')
    sharey = False

    # Optional: convert power to decibels (dB = 10 * log10(power))
    if dB:
        psd = 10 * np.log10(psd)
        psd_welch = 10 * np.log10(psd_welch)
        psd_mt = 10 * np.log10(psd_mt)
        sharey = True

    # Start plot
    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 4), sharex=True, sharey=sharey)
    # Stem
    sc = 'slategrey'
    ax1.stem(freqs, psd, linefmt=sc, basefmt=" ", markerfmt=" ")
    ax2.stem(freqs_welch, psd_welch, linefmt=sc, basefmt=" ", markerfmt=" ")
    ax3.stem(freqs_mt, psd_mt, linefmt=sc, basefmt=" ", markerfmt=" ")
    # Line
    lc, lw = 'k', 2
    ax1.plot(freqs, psd, lw=lw, color=lc)
    ax2.plot(freqs_welch, psd_welch, lw=lw, color=lc)
    ax3.plot(freqs_mt, psd_mt, lw=lw, color=lc)
    # Labels and axes
    ax1.set_xlabel('Frequency (Hz)')
    if not dB:
        ax1.set_ylabel('Power spectral density (V^2/Hz)')
    else:
        ax1.set_ylabel('Decibels (dB)')
    ax1.set_title('Periodogram')
    ax2.set_title('Welch')
    ax3.set_title('Multitaper')
    if band is not None:
        ax1.set_xlim(band)
    ax1.set_ylim(ymin=0)
    ax2.set_ylim(ymin=0)
    ax3.set_ylim(ymin=0)
    sns.despine()

# Example: plot the 0.5 - 2 Hz band
plot_spectrum_methods(data, sf, 4, [0.5, 2], dB=True)
</code></pre>

              <span class="image fit">
          <img src="images/tutorials/bandpower/psd_comp.png" alt="PSD methods comparison"/>
        </span>

              <ul>
                <li>The periodogram has a good frequency resolution (one frequency bin = 0.033 Hz) but way too much variance.</li>
                <li>The Welch's periodogram has a low variance, at the cost of a lower frequency resolution (one frequency bin = 0.25 Hz).</li>
                <li>The multitaper periodogram has the advantages of the two previous methods: high frequency resolution and low variance.</li>
              </ul>

              <h5>Computational cost</h5>

              <pre><code class="python">%timeit bandpower(data, sf, [0.5, 4], method="welch", relative=True)
%timeit bandpower(data, sf, [0.5, 4], method="multitaper", relative=True)
</code></pre>

              <blockquote>
                345 µs ± 8.53 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)<br> 78.9 ms ± 2.82 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
              </blockquote>

              <p align="justify">The multitaper is more computationally intensive than other methods. In the example above, the multitaper method was about 200 times slower than the Welch's method. Using 30-sec of data sampled at 100Hz, the difference in the time of execution
                was about ~70ms. Imagine now having 6 hours of data sampled at 1000Hz, it would take about 3 seconds to compute the periodogram using Welch's method, but almost 10 minutes using the multitaper method!
                <br><br>While the multitaper methods always provide a more robust spectral estimation, I think that it is important to understand that the spectral estimation is case-specific. For example, if you have clean data acquired on young healthy
                individuals, there's a good chance that the multitaper spectral estimation will not differ that much from the Welch's estimate. Furthermore, the Welch's method is probably the most used spectral estimation technique to this day and is
                quite intuitive to understand. By contrast, the multitaper is a relatively new method that is conceptually harder to grasp.
                <p>

                  <h5>Multitaper spectrogram?</h5>

                  <p align="justify">It is also possible to compute a spectrogram (time in the x-axis, spectral density on the y-axis) using the multitaper method. For instance, the <a href="http://visbrain.org/sleep" target="_blank">Sleep module of the Visbrain suite</a> include an option to display a Fourier, wavelet, or multitaper spectrogram. As you can see on the figure below, the multitaper spectrogram is cleaner than the Fourier spectrogram.
                    <p>

                      <span class="image fit">
                      <img src="http://visbrain.org/_images/sleep_spectro_methods.png" alt="Spectrogram"/>
                  </span>


      </div>

      <!-- Footer -->
      <section id="footer">
        <div class="container">
          <ul class="copyright">
            <li>&copy; Raphael Vallat </li>
            <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
            <li>Banner image: Nicholas Roerich</li>
          </ul>
        </div>
      </section>

    </div>

    <!-- Scripts -->
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/jquery.scrollzer.min.js"></script>
    <script src="assets/js/jquery.scrolly.min.js"></script>
    <script src="assets/js/skel.min.js"></script>
    <script src="assets/js/util.js"></script>
    <!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
    <script src="assets/js/main.js"></script>

</body>

</html>
