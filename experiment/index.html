<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
  <head>
    <title>Stocks_test_html [PsychoPy]</title>
    <meta charset="UTF-8">
    <link href="js/vendors//jquery-ui-1.11.4.base/jquery-ui.min.css" rel="stylesheet">

    <style>
        /* project and resource dialogs */
        label, input { display:block; padding-bottom: .5em; }
        input.text { margin-bottom:1em; width:95%; padding: .5em; }
        fieldset { padding:0; border:0; margin-top:25px; }

        /* don't display close button in the top right corner of the box */
        .no-close .ui-dialog-titlebar-close { display: none; }
    </style>
  </head>

  <body>

    <!-- dialog place holder -->
    <div id="dialogDiv"/>

    <script type="text/javascript" src="js/vendors/Math2.js"></script>
    <script type="text/javascript" src="js/vendors/jquery-2.2.0.min.js"></script>
    <script type="text/javascript" src="js/vendors/jquery-ui-1.11.4.base/jquery-ui.min.js"></script>
    <script type="text/javascript" src="js/vendors/jquery.blockUI.js" ></script>
    <script type="text/javascript" src="js/vendors/stats.min.js"></script>
    <script type="text/javascript" src="js/vendors/pixi.min.js"></script>
    <script type="text/javascript" src="js/vendors/papaparse.min.js"></script>
    <script type="text/javascript" src="js/vendors/preloadjs-0.6.2.min.js"></script>

    <script type="text/javascript" src="js/psychojs/main.js"></script>
    <script type="text/javascript" src="js/psychojs/core.js"></script>
    <script type="text/javascript" src="js/psychojs/data.js"></script>
    <script type="text/javascript" src="js/psychojs/events.js"></script>
    <script type="text/javascript" src="js/psychojs/gui.js"></script>
    <script type="text/javascript" src="js/psychojs/util.js"></script>
    <script type="text/javascript" src="js/psychojs/scheduler.js"></script>
    <script type="text/javascript" src="js/psychojs/visual.js"></script>
    <script type="text/javascript" src="js/psychojs/io.js"></script>
    <script type="text/javascript" src="js/psychojs/jamdb.js"></script>
    <script type="text/javascript" src="js/psychojs/colors.js"></script>
    <script type="text/javascript" src="js/psychojs/logging.js"></script>

    <script type='text/javascript'>
      // wait until document is ready:
      $(document).ready(function() {
        psychoJS.debug = true; //false;
        
        function setupExperiment() {
        
          // An ExperimentHandler isn't essential but helps with data saving
          thisExp = new psychoJS.data.ExperimentHandler({
              name: 'Stocks_test_html',
              version: '',
              extraInfo: expInfo,
              runtimeInfo: undefined,  // not yet supported by psychoJS
              originPath: undefined,  //not yet supported by psychoJS
              savePickle: true,       // not yet supported by psychoJS
              saveWideText: true,
              saveTo: 'EXPERIMENT_SERVER',
              /*dataFileName=filename*/});
        
          // setup resource manager:
          psychoJS.resourceManager.set({
                                win:win, downloadFrom:'EXPERIMENT_SERVER', projectId:undefined,
                                projectStatus:'PUBLIC', clock:new psychoJS.core.Clock()
                                });
        
          endExpNow = false; // flag for 'escape' or other condition => quit the exp
        
          // logging:
          psychoJS.logging.console.setLevel(psychoJS.logging.DATA);
          psychoJS.logging.server.set({'level':psychoJS.logging.DATA, 'saveTo':'EXPERIMENT_SERVER', 'experimentInfo': expInfo});
        
          return psychoJS.NEXT;
        }
        
        function updateInfo() {
          expInfo['date'] = psychoJS.data.getDateStr();  // add a simple timestamp
          expInfo['expName'] = expName;
        
          // store frame rate of monitor if we can measure it successfully
          expInfo['frameRate'] = win.getActualFrameRate();
          if (expInfo['frameRate'] != undefined) {
              frameDur = 1.0/Math.round(expInfo['frameRate']);
          }
          else {
              frameDur = 1.0/60.0; // couldn't get a reliable measure so guess
          }
        
          return psychoJS.NEXT;
        }
        
        function setupWin() {
          // Start Code - component code to be run before the window creation
          // Setup the Window
          win = new psychoJS.visual.Window({size:[1920, 1080],
              fullscr:true, screen:1.0,
              allowGUI:false, allowStencil:false,
              monitor:'testMonitor',
              color:[-1.000,-1.000,-1.000], colorSpace:'rgb',
              blendMode:'avg',
              units:'use prefs'
              });
          return psychoJS.NEXT;
        }
        
        function experimentInit() {
          
          // Initialize components for Routine "PicsInstructions"
          PicsInstructionsClock = new psychoJS.core.Clock();
          instructionImage = new psychoJS.visual.ImageStim({
              win : win, name : 'instructionImage',
              image : 'sin', mask : undefined,
              ori : 0, pos : [0, 0], size : [1.5, 1.5],
              color : [1,1,1], colorSpace : 'rgb', opacity : 1,
              flipHoriz : false, flipVert : false,
              texRes : 128, interpolate : true, depth : 0.0 
          });
          
          // Create some handy timers
          globalClock = new psychoJS.core.Clock();  // to track the time since experiment started
          routineTimer = new psychoJS.core.CountdownTimer();  // to track time remaining of each (non-slip) routine
          
          return psychoJS.NEXT;
        }
        
        function PicsInstructionsRoutineBegin() {
          //------Prepare to start Routine 'PicsInstructions'-------
          t = 0;
          PicsInstructionsClock.reset(); // clock
          frameN = -1;
          // update component parameters for each repeat
          instructionImage.setImage(psychoJS.resourceManager.getResource(InstructImages));
          instructions_resp = new psychoJS.event.BuilderKeyResponse();
          // keep track of which components have finished
          PicsInstructionsComponents = [];
          PicsInstructionsComponents.push(instructionImage);
          PicsInstructionsComponents.push(instructions_resp);
          for(var i = 0; i < PicsInstructionsComponents.length; ++i) {
            thisComponent = PicsInstructionsComponents[i];
            if ('status' in thisComponent) {
              thisComponent.status = psychoJS.NOT_STARTED;
            }
          }
          
          return psychoJS.NEXT;
          }
          
          function PicsInstructionsRoutineEachFrame() {
            //------Loop for each frame of Routine 'PicsInstructions'-------
            continueRoutine = true;
             // until we're told otherwise
            // get current time
            t = PicsInstructionsClock.getTime();
            frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
            // update/draw components on each frame
            
            // *instructionImage* updates
            if (t >= 0.0 && instructionImage.status === psychoJS.NOT_STARTED) {
              // keep track of start time/frame for later
              instructionImage.tStart = t;  // (not accounting for frame time here)
              instructionImage.frameNStart = frameN;  // exact frame index
              instructionImage.setAutoDraw(true);
            }
            
            // *instructions_resp* updates
            if (t >= 0.0 && instructions_resp.status === psychoJS.NOT_STARTED) {
              // keep track of start time/frame for later
              instructions_resp.tStart = t;  // (not accounting for frame time here)
              instructions_resp.frameNStart = frameN;  // exact frame index
              instructions_resp.status = psychoJS.STARTED;
              // keyboard checking is just starting
              instructions_resp.clock.reset();  // now t=0
              psychoJS.event.clearEvents({eventType:'keyboard'});
            }
            if (instructions_resp.status == psychoJS.STARTED) {
              theseKeys = psychoJS.event.getKeys({keyList:['1', '2', '3', '4', 'space']});
              
              // check for quit:
              if ("escape" in theseKeys) {
                  endExpNow = true;
              }
              if (theseKeys.length > 0) {  // at least one key was pressed
                instructions_resp.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
                instructions_resp.rt = instructions_resp.clock.getTime();
                // a response ends the routine
                continueRoutine = false;
              }
            }
            
            // check if the Routine should terminate
            if (!continueRoutine) {  // a component has requested a forced-end of Routine
              return psychoJS.NEXT;
            }
            continueRoutine = false;// reverts to True if at least one component still running
            for(var i = 0; i < PicsInstructionsComponents.length; ++i) {
              thisComponent = PicsInstructionsComponents[i];
              if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                continueRoutine = true;
                break;
              }
            }
            // check for quit (the Esc key)
            if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
              psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
            }
            
            // refresh the screen if continuing
            if (continueRoutine) {
              return psychoJS.FLIP_REPEAT;
            }
            else {
              return psychoJS.NEXT;
            }
          }
          
          function PicsInstructionsRoutineEnd() {
            //------Ending Routine 'PicsInstructions'-------
            for (var i = 0; i < PicsInstructionsComponents.length; ++i) {
              thisComponent = PicsInstructionsComponents[i];
              if ("setAutoDraw" in thisComponent) {
                thisComponent.setAutoDraw(false);
              }
            }
            // check responses
            if (['', [], undefined].indexOf(instructions_resp.keys) >= 0) {    // No response was made
                instructions_resp.keys = undefined;
            }
            thisExp.addData('instructions_resp.keys',instructions_resp.keys);
            if (instructions_resp.keys != undefined) {  // we had a response
                thisExp.addData('instructions_resp.rt', instructions_resp.rt)
            }
            // the Routine "PicsInstructions" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset();
            return psychoJS.NEXT;
          }
          
          function registerResources() {
              psychoJS.resourceManager.scheduleRegistration(resourceScheduler);
          
              return psychoJS.NEXT;
          }
          
          function downloadResources() {
              psychoJS.resourceManager.scheduleDownload(resourceScheduler);
          
              return psychoJS.NEXT;
          }
          
          function InstructionsLoopBegin(thisScheduler) {
            // set up handler to look after randomisation of conditions etc
            try {
              Instructions = new psychoJS.data.TrialHandler({nReps:1, method:'sequential',
                extraInfo:expInfo, originPath:undefined,
                trialList:psychoJS.data.importConditions('Instructions\\InstructionConditions.csv'),
                seed:undefined, name:'Instructions'});
              thisExp.addLoop(Instructions); // add the loop to the experiment
              thisInstruction = Instructions.trialList[Instructions.trialSequence[0]]; // so we can initialise stimuli with some values
              // abbreviate parameter names if possible (e.g. rgb=thisInstruction.rgb)
              abbrevNames(thisInstruction);
              // Schedule each of the trials in the list to occur
              for (var i = 0; i < Instructions.trialSequence.length; ++i) {
                thisInstruction = Instructions.trialList[Instructions.trialSequence[i]];
                thisScheduler.add(abbrevNames(thisInstruction));
                thisScheduler.add(PicsInstructionsRoutineBegin);
                thisScheduler.add(PicsInstructionsRoutineEachFrame);
                thisScheduler.add(PicsInstructionsRoutineEnd);
              }
            } catch (exception) {
              console.log(exception);
            }
          
            return psychoJS.NEXT;
          }
          
          function InstructionsLoopEnd() {
            // get names of stimulus parameters
            if (psychoJS.isEmpty(Instructions.trialList)) { // XXX equiv of : in ([], [None], None)
              params = [];
            }
            else {
              params = Object.keys(Instructions.trialList[0]);
            }
          
            // save data for this loop
            thisExp.loopEnded(Instructions);
            return psychoJS.NEXT;
            }
          
          function run() {
            // init psychoJS and set up OpenGL Canvas
            setupWin();
            psychoJS.init(win);
            
            // main scheduler
            scheduler = new psychoJS.Scheduler();
            
            // Store info about the experiment session
            expName = 'stroop';  // from the Builder filename that created this script
            expInfo = {'participant':'', 'session':'01'};
            
            // set up experiment
            scheduler.add(setupExperiment);
            scheduler.add(psychoJS.setupCallbacks);
            
            // register all available resources and download them
            resourceScheduler = new psychoJS.Scheduler();
            resourceScheduler.add(registerResources);
            resourceScheduler.add(downloadResources);
            // asynchronous approach: the resource scheduler is run in parallel to the main one
            scheduler.add(function() { resourceScheduler.start(win); });
            
            // dialog box
            scheduler.add(psychoJS.gui.DlgFromDict({dictionary:expInfo, title:expName}));
            
            flowScheduler = new psychoJS.Scheduler();
            dialogCancelScheduler = new psychoJS.Scheduler();
            scheduler.addConditionalBranches(function() { return psychoJS.gui.dialogComponent.button === 'OK'; }, flowScheduler, dialogCancelScheduler);
            
            // flowScheduler gets run if the participants presses OK
            flowScheduler.add(updateInfo); // add timeStamp
            flowScheduler.add(experimentInit);
            InstructionsLoopScheduler = new psychoJS.Scheduler();
            flowScheduler.add(InstructionsLoopBegin, InstructionsLoopScheduler);
            flowScheduler.add(InstructionsLoopScheduler);
            flowScheduler.add(InstructionsLoopEnd);
            flowScheduler.add(quitPsychoJS);
            
            // quit if user presses Cancel in dialog box:
            dialogCancelScheduler.add(quitPsychoJS);
            
            scheduler.start(win);
          }
          
          function abbrevNames(thisTrial) {
            return function () {
              // abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)
              if (thisTrial != undefined) {
                for (paramName in thisTrial) {
                  window[paramName] = thisTrial[paramName];
                }
              }
              return psychoJS.NEXT;
            };
          }
          
          function recordLoopIteration(currentLoop) {
            return function () {
              currentLoop.updateAttributesAtBegin();
              thisExp.nextEntry();
              return psychoJS.NEXT;
            }
          }
          
          function quitPsychoJS() {
              thisExp.save();
              win.close()
              psychoJS.core.quit();
              return psychoJS.QUIT;
          }

        run();
      });
    </script>

  </body>
</html>
